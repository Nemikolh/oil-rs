use tok::{self, Tok};
use std::str::FromStr;
use ast::*;
use lalrpop_util::ParseError;
use std::collections::HashMap;

grammar<'input>;

pub ui_package: Package = {
    <vi:import*> <items:template_or_style_or_view*> => {
        Package {
            imports: vi,
            items: items,
        }
    },
};

import: Import = {
    "import" <c:components> "from" <p:path> ";" => {
        Import {
            components: c,
            path: p.to_string(),
        }
    },
    "import" <p:path> ";" => {
        Import {
            components: Components::All,
            path: p.to_string(),
        }
    },
};

components: Components = {
    "*" => Components::All,
    "{" <v:comma<ident>> "}" => {
        Components::Only(v.into_iter().map(|s| s.to_string()).collect())
    },
    <lo:@L> <font_or_img:ident> =>? {
        if font_or_img == "$font" {
            Ok(Components::Font)
        } else if font_or_img == "$img" {
            Ok(Components::Img)
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: lo,
                    code: tok::ErrorCode::OnlyFontOrImg
                }
            })
        }
    },
};

template_or_style_or_view: Item = {
    <t:template> => Item::Template(t),
    <c:style> => Item::Class(c),
    view => Item::View,
};

path: &'input str = {
    "StringLiteral",
};

ident: &'input str = <s:"Id"> => s.as_str();

number: f32 = <n:"Number"> => f32::from_str(n).unwrap();

property: tok::StrView<'input> = {
    "Id",
    <p:property> <d:"DotId"> => p.merge(d),
};

// =================================
//          Templates
//

template: Template = {
    <ex:export?> "template" <n:ident>
    <args:template_args?> <events:trigg_events?> "=" <ns:node*> ";" => {
        Template {
            exported: ex.is_some(),
            name: n.to_string(),
            arguments: args.unwrap_or(vec![]),
            events: events.unwrap_or(vec![]),
            nodes: ns,
        }
    },
};

export: () = "export" => ();

template_args: Vec<String> = {
    <arg:ident> => vec![arg.to_string()],
    "[" <args:comma<ident>> "]" =>
        args.into_iter().map(|s| s.to_string()).collect(),
};

trigg_events: Vec<String> = {
    "->" <evs:events> => evs,
};

events: Vec<String> = {
    <ev:ident> => vec![ev.to_string()],
    "(" <evs:comma<ident>> ")" =>
        evs.into_iter().map(|s| s.to_string()).collect(),
};

node: Node = {
    // Some tag
    "<" <lo:@L> <tag_open:ident> <hi:@R> <cl:class?> <args:node_args*> <ev:node_events*> ">" node*
    "</" <errlo:@L> <tag_close:ident> ">" =>? {
        if tag_open == tag_close {
            Ok(Node {
                span: Span(lo, hi),
                kind: NodeKind::Tag {
                    class: cl,
                    arguments: args,
                    events: ev,
                },
            })
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: errlo,
                    code: tok::ErrorCode::UnmatchingTag,
                }
            })
        }
    },
    // Selection
    "<" <selo:@L> <select:ident> ":" <qulo:@L> <query:ident> <hi:@R> "/>" =>? {
        if select == "select" {
            if query == "children" {
                Ok(Node {
                    span: Span(selo, hi),
                    kind: NodeKind::Query {
                        kind: QueryKind::Children
                    }
                })
            } else {
                Err(ParseError::User {
                    error: tok::Error {
                        location: qulo,
                        code: tok::ErrorCode::InvalidQuery,
                    }
                })
            }
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: selo,
                    code: tok::ErrorCode::InvalidSelect,
                }
            })
        }
    },
    node_text,
};

node_text: Node = {
    // Text Node (pure text)
    <lo:@L> <t:"TextNode"> <hi:@R> => Node {
        span: Span(lo, hi),
        kind: NodeKind::Text { content: t.to_string() },
    },
    // A text binding
    <lo:@L> "{" <p:property> "}" <hi:@R> => Node {
        span: Span(lo, hi),
        kind: NodeKind::Binding { property: p.to_string() },
    },
};

class: () = ident "=" class_value => ();

node_args: () = {
    "[" ident "]" "=" arg_value => (),
};

node_events: () = {
    "(" ident ")" "=" property => (),
};

class_value: () = {
    property => (),
    anonymous_class => (),
};

anonymous_class: () = {
    "{" "}" => (),
};

arg_value: () = {
    property => (),
    object_value => (),
    "StringLiteral" => (),
};

object_value: () = {
    "{" "}" => (),
};

// =================================
//          Styles
//

style: Class = {
    <ex:export?> <name:"DotId"> "{" <props:style_properties*> "}" => {
        Class {
            exported: ex.is_some(),
            name: (&*name)[1..].to_string(),
            properties: props.into_iter().collect(),
        }
    },
};

style_properties: (String, StyleProperty) = {
    <i:ident> ":" <s:style_value> => (i.to_string(), s),
};

style_value: StyleProperty = {
    // Shall we have this case?
    // "{" ident "}" =>
    <n:number> <li:@L> <u:ident> ";" =>? match u {
        "px" => Ok(StyleProperty::Number(n, Unit::Px)),
        _ => Err(ParseError::User {
            error: tok::Error {
                location: li,
                code: tok::ErrorCode::InvalidUnit
            }
        })
    },
    <h:"Hex"> ";" => StyleProperty::Hex(h.to_string()),
    <font_or_img:ident>  <prop:img_props?> ";" => {
        match prop {
            Some(_) => {
                // TODO:
                assert_eq!(font_or_img, "$img");
                StyleProperty::Font
            },
            None => {
                assert!(font_or_img == "$font" || font_or_img == "$img");
                StyleProperty::Font
            }
        }
    },
};

img_props: Vec<(Option<&'input str>, f32)> = {
    "[" <v:comma<img_prop>> "]" => v,
};

img_prop: (Option<&'input str>, f32) = {
    <i:ident> ":" <n:number> => (Some(i), n),
    <n:number> => (None, n),
};

// =================================
//          View
//

view: () = {
    "view" "Id" view_args "=" node ";" => (),
};

view_args: () = {
    "(" ident "," ident ")" => (),
};

// =================================
//          Macros
//

comma<T>: Vec<T> =
    <v:(<T> ",")*> <o:T?> =>
        v.into_iter().chain(o).collect();

// =================================
//          Tokens
//
extern {
    type Location = usize;
    type Error = tok::Error;
    enum Tok<'input> {
        "import" => Tok::Import,
        "from" => Tok::From,
        "view" => Tok::View,
        "template" => Tok::Template,
        "export" => Tok::Export,

        // Special keywords accompanied by a series of
        // uninterpreted strings representing path
        "StringLiteral" => Tok::StringLiteral(<&'input str>),
        "Number" => Tok::Number(<&'input str>),
        "Hex" => Tok::Hex(<&'input str>),

        "TextNode" => Tok::TextNode(<&'input str>), // Includes binded properties

        // Identifiers of various kinds:
        "DotId" => Tok::DotId(<tok::StrView<'input>>), // excludes the '.'
        "Id" => Tok::Id(<tok::StrView<'input>>),

        "->" => Tok::Arrow,

        "{" => Tok::LeftBrace,
        "}" => Tok::RightBrace,
        "[" => Tok::LeftBracket,
        "]" => Tok::RightBracket,
        "(" => Tok::LeftParen,
        ")" => Tok::RightParen,
        "<" => Tok::LessThan,
        "</" => Tok::LessThanSlash,
        ">" => Tok::GreaterThan,
        "/>" => Tok::SlashGreaterThan,
        //"#" => Tok::Hash,
        //"?" => Tok::Question,
        "=" => Tok::Equals,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        ";" => Tok::Semi,
        "*" => Tok::Star,
        ":" => Tok::Colon,
        "," => Tok::Comma,
    }
}
