use tok::{self, Tok};
use std::str::FromStr;
use ast::*;
use ast::builder::ASTBuilder;
use lalrpop_util::ParseError;
use lalrpop_intern::{intern, InternedString};


grammar<'input, B>(_builder: &B) where B: ASTBuilder;

pub ui_package: Package = {
    <vi:import*> <items:component_or_style_or_view*> => B::package(vi, items),
};

import: Import = {
    "import" <s:import_symbols> "from" <lo:@L> <p:path> <hi:@R> ";" => {
        B::import(Span(lo, hi), s, intern(p))
    },
    "import" <lo:@L> <p:path> <hi:@R> ";" => {
        B::import(Span(lo, hi), ImportSymbols::All, intern(p))
    },
};

path: &'input str = {
    "StringLiteral",
};

import_symbols: ImportSymbols = {
    "*" => ImportSymbols::All,
    "{" <v:comma<identspan>> "}" => ImportSymbols::Only(v),
    <id:identspan> => ImportSymbols::AllAsIdent(id),
};

component_or_style_or_view: Item = {
    component => Item::Component(<>),
    style => Item::Class(<>),
    view => Item::View(<>),
};

// =================================
//          Components
//

component: Component = {
    <ex:"export"?> "component" <n:identspan> <args:component_args?> <events:trigg_events?> "="
        <body:component_body> =>
    {
        B::cpt(ex.is_some(), n, args.unwrap_or(vec![]), events.unwrap_or(vec![]), body)
    },
};

component_body: ComponentBody = {
    "{" <ns:node> "}" => {
        ComponentBody::PreludeThenSingleNode(None, ns)
    },
    <ns:node> ";" => {
        ComponentBody::SingleNode(ns)
    },
};

component_args: Vec<Ident> = {
    <arg:identspan> => vec![arg],
    "[" <comma<identspan>> "]" => <>,
};

trigg_events: Vec<Ident> = {
    "->" <evs:events> => evs,
};

events: Vec<Ident> = {
    <ev:identspan> => vec![ev],
    "(" <comma<identspan>> ")" => <>,
};

node: Node = {
    node_tag,
    node_text,
};

node_tag: Node = {
    // Some tag
    "<" <lo:@L> <tag_open:ident> <hi:@R>
        <cl:class?>
        <args:node_args*>
        <ev:node_events*>
    ">"
        <children:node_child*>
    "</" <errlo:@L> <tag_close:ident> ">" =>? {
        if tag_open == tag_close {
            Ok(Node {
                span: Span(lo, hi),
                children: children,
                kind: NodeKind::Tag {
                    name: intern(tag_open),
                    class: cl,
                    arguments: args,
                    events: ev,
                },
            })
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: errlo,
                    code: tok::ErrorCode::UnmatchingTag,
                }
            })
        }
    },
};

node_text: Node = {
    <lo:@L> <c:node_text_sp+> <hi:@R> => B::node_agg(Span(lo, hi), c),
};

node_child: Node = {
    node_tag,
    node_text_sp,
};

node_text_sp: Node = {
    // Text Node (pure text)
    <lo:@L> <t:"TextNode"> <hi:@R> => B::node_txt(Span(lo, hi), intern(t)),
    // A text binding
    <lo:@L> "{" "{" <p:property> "}" "}" <hi:@R> => B::node_binding(Span(lo, hi), p),
};

class: AnonymousClassOrIdent =
    <lo:@L> <clkw:ident> "=" <val:class_value> =>? {
        if clkw == "class" {
            Ok(val)
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: lo,
                    code: tok::ErrorCode::UnrecognizedToken,
                }
            })
        }
    };

class_value: AnonymousClassOrIdent = {
    <id:ident> => AnonymousClassOrIdent::Ident(intern(id)),
    <ac:anonymous_class> => AnonymousClassOrIdent::AnCls(ac),
};

node_args: (Ident, ObjectValue) = {
    "[" <i:identspan> "]" "=" "{" <a:object> "}" => (i, a),
};

node_events: (Ident, ()) = {
    "(" <i:identspan> ")" "=" "{" <p:eventchain> "}" => (i, p),
};

// =================================
//          Event chain
//

eventchain: () = {
    expression => (),
};

// =================================
//          Styles
//

anonymous_class: AnonymousClass = {
    "{" <props:style_property_or_include*> "}" => {
        AnonymousClass {
            properties: props,
        }
    },
};

style: Class = {
    <ex:"export"?> <lo:@L> "." <name:identspan> <hi:@R> <args:arguments?> "{"
        <props:style_property_or_include*>
    "}" => {
        Class {
            exported: ex.is_some(),
            name: name,
            arguments: args.unwrap_or(vec![]),
            properties: props,
        }
    },
};

style_property_or_include: RawPropertyOrInclude = {
    <prop:style_property> <cond:style_condition?> ";" =>
        RawPropertyOrInclude::RawProperty((prop.0, StyleValueCond { prop: prop.1, cond: cond })),
    <incl:style_include>  <cond:style_condition?> ";" =>
        RawPropertyOrInclude::Include(IncludeCond { incl: incl, cond: cond }),
    "&" ":" <i:identspan> "{" <props:style_property_or_include> "}" => unimplemented!(),
};

style_include: Include = {
    <lo:@L> "." <name:identspan> <hi:@R> <args:arguments?> => {
        Include {
            name: name,
            arguments: args.unwrap_or(vec![]),
        }
    },
};

style_property: (InternedString, StyleValue) = {
    <i:ident> ":" <s:style_value> => (intern(i), s),
};

style_condition: Box<Expr> = {
    "if" <boolean_expression> => Box::new(<>),
};

style_value: StyleValue = {
    "Hex" => StyleValue::Hex(intern(<>)),
    expression => B::style_value(<>),

    // <le:@L> <e:expression> <li:@L> <prop:img_view_or_unit?> =>? {
    //     match prop {
    //         Some(ImgViewOrUnit::ImgView(sub_img)) => {
    //             if !is_valid_img_range(&sub_img) {
    //                 Err(ParseError::User {
    //                     error: tok::Error {
    //                         location: li,
    //                         code: tok::ErrorCode::InvalidRange,
    //                     }
    //                 })
    //             } else if let Expr::VarAccess(access) = *e {
    //                 let x_pos = sub_img.iter()
    //                     .position(|&x| x.0.map(|a| a == "x").unwrap_or(false))
    //                     .unwrap_or(0);
    //                 let y_pos = sub_img.iter()
    //                     .position(|&x| x.0.map(|a| a == "y").unwrap_or(false))
    //                     .unwrap_or(1);
    //                 let w_pos = sub_img.iter()
    //                     .position(|&x| x.0.map(|a| a == "w").unwrap_or(false))
    //                     .unwrap_or(2);
    //                 let h_pos = sub_img.iter()
    //                     .position(|&x| x.0.map(|a| a == "h").unwrap_or(false))
    //                     .unwrap_or(3);
    //                 Ok(StyleValue::Img {
    //                     ident: intern(access),
    //                     view_x: sub_img.get(x_pos).map(|&x| x.1),
    //                     view_y: sub_img.get(y_pos).map(|&x| x.1),
    //                     view_w: sub_img.get(w_pos).map(|&x| x.1),
    //                     view_h: sub_img.get(h_pos).map(|&x| x.1),
    //                 })
    //             } else {
    //                 Err(ParseError::User {
    //                     error: tok::Error {
    //                         location: le,
    //                         code: tok::ErrorCode::InvalidVarName
    //                     }
    //                 })
    //             }
    //         }
    //         Some(ImgViewOrUnit::Unit(u)) => {
    //             Ok(StyleValue::Length(e, u))
    //         }
    //         None => {
    //             Ok(StyleValue::Unspecified(e))
    //         }
    //     }
    // },
};

// style_unit: Unit = {
//     <li:@L> <u:ident> =>? match u {
//         "px" => Ok(Unit::Px),
//         _ => Err(ParseError::User {
//             error: tok::Error {
//                 location: li,
//                 code: tok::ErrorCode::InvalidUnit
//             }
//         })
//     },
// };

// img_view_or_unit: ImgViewOrUnit<'input> = {
//     <prop:img_props> => ImgViewOrUnit::ImgView(prop),
//     <unit:style_unit> => ImgViewOrUnit::Unit(unit),
// };

// img_props: Vec<(Option<&'input str>, f32)> = {
//     "[" <v:comma<img_prop>> "]" => v,
// };

// img_prop: (Option<&'input str>, f32) = {
//     <i:ident> ":" <n:number> => (Some(i), n),
//     <n:number> => (None, n),
// };

// =================================
//          Constants
//

constants: ConstValue = {
    <e:"export"?> "const" <n:identspan> "=" <o:object> ";" => B::const_value(e.is_some(), n, o),
};

// =================================
//          View
//

view: View = {
    "view" <identspan> "=" <node> ";" => B::view(<>),
};

// =================================
//          Macros
//

comma<T>: Vec<T> =
    <v:(<T> ",")*> <o:T?> =>
        v.into_iter().chain(o).collect();

// =================================
//          Objects
//

// Almost similar as below. Note the difference
// with expression replaced by property
// This is needed to avoid a problem with expression
// that need to be wrapped
// object_as_arg_value: ObjectValue = {
//     <p:property> =>
//         ObjectValue::Expr(Box::new(Expr::PathExpr(p))),
//     "{" <exp:expression> "}" => ObjectValue::Expr(exp),
//     "{" <entries:comma<object_entry>> "}" =>
//         ObjectValue::Props(entries.into_iter().collect()),
// };

object: ObjectValue = {
    expression => ObjectValue::Expr(Box::new(<>)),
    "{" <entries:comma<object_entry>> "}" =>
        ObjectValue::Props(entries.into_iter().collect()),
};

object_entry: (InternedString, ObjectValue) = {
    <p:ident> ":" <e:object> => (intern(p), e),
};

// =================================
//          Miscellaneous
//

number: f32 = <n:"Number"> => f32::from_str(n).unwrap();

arguments_obj: Vec<ObjectValue> = {
    "(" <comma<object>> ")" => <>,
};

arguments: Vec<Ident> = {
    "(" <comma<identspan>> ")" => <>,
};

ident: &'input str = <s:"Id"> => s;

// =================================
//          Expressions
//

boolean_expression: Expr = {
    expression,
};

expression: Expr = {
    simple_expression,
    simple_expression relop simple_expression => B::binaryop(<>),
};

simple_expression: Expr = {
    term,
    simple_expression addop term => B::binaryop(<>),
};

term: Expr = {
    factor,
    term mulop factor => B::binaryop(<>),
};

factor: Expr = {
    sign factor => B::signed(<>),
    exponentiation,
};

exponentiation: Expr = {
    primary,
    primary powop exponentiation => B::binaryop(<>),
};

primary: Expr = {
    "StringLiteral" => B::strlit(intern(<>)),
    "true" => B::boolean(true),
    "false" => B::boolean(false),
    property => B::path(<>),
    constant => B::const_to_expr(<>),
    "(" <expression> ")" => <>,
    "!" <primary> => B::not(<>),
};

property: PathExpr = {
    <e:property> "." <p:identspan> => B::propaccess(e, p),
    <e:property> "?" <i:identspan?> => {
        match i {
            Some(i) => B::propaccess(B::option(e), i),
            None => B::option(e),
        }
    },
    <e:property> "[" <i:constant> "]" => B::index(e, i),
    identspan => B::variable(<>),
};

identspan: Ident = <lo:@L> <i:ident> <hi:@R> => Ident {
    span: Span(lo, hi),
    name: intern(i),
};

constant: Constant = {
    "Number" => B::constant(<>),
};

sign: Sign = {
    "+" => Sign::Plus,
    "-" => Sign::Minus,
};

addop: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
    "||" => OpCode::Or,
};

mulop: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
    "%" => OpCode::Mod,
    "&&" => OpCode::And,
};

relop: OpCode = {
    "==" => OpCode::EqEq,
    "!=" => OpCode::NotEq,
    "<" => OpCode::LessThan,
    ">" => OpCode::GreaterThan,
    "<=" => OpCode::LessThanOrEq,
    ">=" => OpCode::GreaterThanOrEq,
};

powop: OpCode = {
    "^" => OpCode::Pow,
};

// =================================
//          Tokens
//
extern {
    type Location = usize;
    type Error = tok::Error;
    enum Tok<'input> {
        "import" => Tok::Import,
        "from" => Tok::From,
        "view" => Tok::View,
        "const" => Tok::Const,
        "let" => Tok::Let,
        "component" => Tok::Component,
        "export" => Tok::Export,
        "true" => Tok::True,
        "false" => Tok::False,

        // Style specific tokens
        "if" => Tok::If,
        "&" => Tok::Ampersand,

        // Special keywords accompanied by a series of
        // uninterpreted strings representing path
        "StringLiteral" => Tok::StringLiteral(<&'input str>),
        "Number" => Tok::Number(<&'input str>),
        "Hex" => Tok::Hex(<&'input str>),

        "TextNode" => Tok::TextNode(<&'input str>), // Includes binded properties

        // Identifiers of various kinds:
        "Id" => Tok::Id(<&'input str>),

        "->" => Tok::Arrow,

        "{" => Tok::LeftBrace,
        "}" => Tok::RightBrace,
        "[" => Tok::LeftBracket,
        "]" => Tok::RightBracket,
        "(" => Tok::LeftParen,
        ")" => Tok::RightParen,
        "<" => Tok::LessThan,
        "</" => Tok::LessThanSlash,
        ">" => Tok::GreaterThan,
        "/>" => Tok::SlashGreaterThan,

        // Boolean expressions
        "&&" => Tok::And,
        "||" => Tok::Or,
        ">=" => Tok::GreaterThanOrEqual,
        "<=" => Tok::LessThanOrEqual,
        "==" => Tok::EqualsEquals,
        "!=" => Tok::BangEquals,
        //"#" => Tok::Hash,
        "?" => Tok::Question,
        "/" => Tok::Div,
        "%" => Tok::Mod,
        "|" => Tok::Pipe,
        "!" => Tok::Bang,
        "^" => Tok::Caret,
        "=" => Tok::Equals,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        ";" => Tok::Semi,
        "*" => Tok::Star,
        ":" => Tok::Colon,
        "," => Tok::Comma,
        "." => Tok::Dot,
    }
}
