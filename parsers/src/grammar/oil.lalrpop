use tok::{self, Tok};
use std::str::FromStr;
use ast::*;
use lalrpop_util::ParseError;
use lalrpop_intern::{intern, InternedString};
use std::collections::HashMap;


grammar<'input>;

pub ui_package: Package = {
    <vi:import*> <items:component_or_style_or_view*> => {
        Package {
            imports: vi,
            items: items,
        }
    },
};

import: Import = {
    "import" <s:import_symbols> "from" <lo:@L> <p:path> <hi:@R> ";" => {
        Import {
            span: Span(lo, hi),
            symbols: s,
            package: SubPackage::UnresolvedPath(intern(p)),
        }
    },
    "import" <lo:@L> <p:path> <hi:@R> ";" => {
        Import {
            span: Span(lo, hi),
            symbols: ImportSymbols::All,
            package: SubPackage::UnresolvedPath(intern(p)),
        }
    },
};

import_symbols: ImportSymbols = {
    "*" => ImportSymbols::All,
    "{" <v:comma<identspan>> "}" => ImportSymbols::Only(v),
    <id:identspan> => ImportSymbols::AllAsIdent(id),
};

component_or_style_or_view: Item = {
    component => Item::Component(<>),
    style => Item::Class(<>),
    view => Item::View(<>),
};

identspan: Ident = <lo:@L> <i:ident> <hi:@R> => Ident {
    span: Span(lo, hi),
    name: intern(i),
};

path: &'input str = {
    "StringLiteral",
};

ident: &'input str = <s:"Id"> => s.as_str();

number: f32 = <n:"Number"> => f32::from_str(n).unwrap();

property: tok::StrView<'input> = {
    "Id",
    <p:property> <d:"DotId"> => p.merge(d),
};

// =================================
//          Components
//

component: Component = {
    <ex:export?> "component" <n:ident>
    <args:component_args?> <events:trigg_events?> "=" <ns:node*> ";" => {
        Component {
            exported: ex.is_some(),
            name: intern(n),
            arguments: args.unwrap_or(vec![]),
            events: events.unwrap_or(vec![]),
            nodes: ns,
        }
    },
};

export: () = "export" => ();

component_args: Vec<Ident> = {
    <arg:identspan> => vec![arg],
    "[" <comma<identspan>> "]" => <>,
};

trigg_events: Vec<Ident> = {
    "->" <evs:events> => evs,
};

events: Vec<Ident> = {
    <ev:identspan> => vec![ev],
    "(" <comma<identspan>> ")" => <>,
};

node: Node = {
    // Some tag
    "<" <lo:@L> <tag_open:ident> <hi:@R>
        <cl:class?>
        <args:node_args*>
        <ev:node_events*>
    ">"
        <children:node*>
    "</" <errlo:@L> <tag_close:ident> ">" =>? {
        if tag_open == tag_close {
            Ok(Node {
                span: Span(lo, hi),
                children: children,
                kind: NodeKind::Tag {
                    name: intern(tag_open),
                    class: cl,
                    arguments: args,
                    events: ev,
                },
            })
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: errlo,
                    code: tok::ErrorCode::UnmatchingTag,
                }
            })
        }
    },
    node_text,
};

node_text: Node = {
    // Text Node (pure text)
    <lo:@L> <t:"TextNode"> <hi:@R> => Node {
        span: Span(lo, hi),
        children: vec![],
        kind: NodeKind::Text { content: intern(t) },
    },
    // A text binding
    <lo:@L> "{" "{" <p:property> "}" "}" <hi:@R> => Node {
        span: Span(lo, hi),
        children: vec![],
        kind: NodeKind::Binding { property: intern(p.as_str()) },
    },
};

class: AnonymousClassOrIdent =
    <lo:@L> <clkw:ident> "=" <val:class_value> =>? {
        if clkw == "class" {
            Ok(val)
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: lo,
                    code: tok::ErrorCode::UnrecognizedToken,
                }
            })
        }
    };

class_value: AnonymousClassOrIdent = {
    <id:ident> => AnonymousClassOrIdent::Ident(intern(id)),
    <ac:anonymous_class> => AnonymousClassOrIdent::AnCls(ac),
};

node_args: (Ident, ObjectValue) = {
    "[" <i:identspan> "]" "=" "{" <a:object_as_arg_value> "}" => (i, a),
};

node_events: (Ident, ()) = {
    "(" <i:identspan> ")" "=" "{" <p:eventchain> "}" => (i, p),
};

// =================================
//          Event chain
//

eventchain: () = {
    // TODO
};

// =================================
//          Styles
//

anonymous_class: AnonymousClass = {
    "{" <props:style_property_or_include*> "}" => {
        AnonymousClass {
            properties: props,
        }
    },
};

style: Class = {
    <ex:export?> <lo:@L> <name:"DotId"> <hi:@R> <args:arguments?> "{"
        <props:style_property_or_include*>
    "}" => {
        Class {
            exported: ex.is_some(),
            name: Ident {
                span: Span(lo, hi),
                name: intern(&(&*name)[1..]),
            },
            arguments: args.unwrap_or(vec![]),
            properties: props,
        }
    },
};

style_property_or_include: RawPropertyOrInclude = {
    <prop:style_property> <cond:style_condition?> ";" =>
        RawPropertyOrInclude::RawProperty((prop.0, StyleValueCond { prop: prop.1, cond: cond })),
    <incl:style_include>  <cond:style_condition?> ";" =>
        RawPropertyOrInclude::Include(IncludeCond { incl: incl, cond: cond }),
    "&" ":" <i:identspan> "{" <props:style_property_or_include> "}" => unimplemented!(),
};

style_include: Include = {
    <lo:@L> <name:"DotId"> <hi:@R> <args:arguments?> => {
        Include {
            name: Ident { name: intern(&(&*name)[1..]) span: Span(lo, hi) },
            arguments: args.unwrap_or(vec![]),
        }
    },
};

style_property: (InternedString, StyleValue) = {
    <i:ident> ":" <s:style_value> => (intern(i), s),
};

style_condition: Box<Expr> = {
    "@if" <boolean_expression> => <>,
};

style_value: StyleValue = {
    <s:"StringLiteral"> => StyleValue::Keyword(intern(s)),
    <h:"Hex"> => StyleValue::Hex(intern(h)),
    <le:@L> <e:expression> <li:@L> <prop:img_view_or_unit?> =>? {
        match prop {
            Some(ImgViewOrUnit::ImgView(sub_img)) => {
                if !is_valid_img_range(&sub_img) {
                    Err(ParseError::User {
                        error: tok::Error {
                            location: li,
                            code: tok::ErrorCode::InvalidRange,
                        }
                    })
                } else if let Expr::VarAccess(access) = *e {
                    let x_pos = sub_img.iter()
                        .position(|&x| x.0.map(|a| a == "x").unwrap_or(false))
                        .unwrap_or(0);
                    let y_pos = sub_img.iter()
                        .position(|&x| x.0.map(|a| a == "y").unwrap_or(false))
                        .unwrap_or(1);
                    let w_pos = sub_img.iter()
                        .position(|&x| x.0.map(|a| a == "w").unwrap_or(false))
                        .unwrap_or(2);
                    let h_pos = sub_img.iter()
                        .position(|&x| x.0.map(|a| a == "h").unwrap_or(false))
                        .unwrap_or(3);
                    Ok(StyleValue::Img {
                        ident: intern(access),
                        view_x: sub_img.get(x_pos).map(|&x| x.1),
                        view_y: sub_img.get(y_pos).map(|&x| x.1),
                        view_w: sub_img.get(w_pos).map(|&x| x.1),
                        view_h: sub_img.get(h_pos).map(|&x| x.1),
                    })
                } else {
                    Err(ParseError::User {
                        error: tok::Error {
                            location: le,
                            code: tok::ErrorCode::InvalidVarName
                        }
                    })
                }
            }
            Some(ImgViewOrUnit::Unit(u)) => {
                Ok(StyleValue::Length(e, u))
            }
            None => {
                Ok(StyleValue::Unspecified(e))
            }
        }
    },
};

style_unit: Unit = {
    <li:@L> <u:ident> =>? match u {
        "px" => Ok(Unit::Px),
        _ => Err(ParseError::User {
            error: tok::Error {
                location: li,
                code: tok::ErrorCode::InvalidUnit
            }
        })
    },
};

img_view_or_unit: ImgViewOrUnit<'input> = {
    <prop:img_props> => ImgViewOrUnit::ImgView(prop),
    <unit:style_unit> => ImgViewOrUnit::Unit(unit),
};

img_props: Vec<(Option<&'input str>, f32)> = {
    "[" <v:comma<img_prop>> "]" => v,
};

img_prop: (Option<&'input str>, f32) = {
    <i:ident> ":" <n:number> => (Some(i), n),
    <n:number> => (None, n),
};

// =================================
//          Constants
//

constants: ConstValue = {
    <e:export?> "const" <n:ident> "=" <o:object> ";" => ConstValue {
        exported: e.is_some(),
        name: intern(n),
        properties: o,
    },
};

// =================================
//          View
//

view: View = {
    "view" <i:ident> <args:view_args> "=" <n:node> ";" => View {
        name: intern(i),
        model_name: args.0,
        handlers_name: args.1,
        node: n,
    },
};

view_args: (String, String) = {
    "(" <m:ident> "," <h:ident> ")" => (intern(m), intern(h)),
};

// =================================
//          Macros
//

comma<T>: Vec<T> =
    <v:(<T> ",")*> <o:T?> =>
        v.into_iter().chain(o).collect();

// =================================
//          Objects
//

// Almost similar as below. Note the difference
// with expression replaced by property
// This is needed to avoid a problem with expression
// that need to be wrapped
object_as_arg_value: ObjectValue = {
    <s:"StringLiteral"> => ObjectValue::StrLit(intern(s)),
    <p:property> =>
        ObjectValue::Expr(Box::new(Expr::VarAccess(intern(p)))),
    "{" <exp:expression> "}" => ObjectValue::Expr(exp),
    "{" <entries:comma<object_entry>> "}" =>
        ObjectValue::Props(entries.into_iter().collect()),
};

object: ObjectValue = {
    <s:"StringLiteral"> => ObjectValue::StrLit(intern(s)),
    <exp:expression> => ObjectValue::Expr(exp),
    "{" <entries:comma<object_entry>> "}" =>
        ObjectValue::Props(entries.into_iter().collect()),
};

object_entry: (String, ObjectValue) = {
    <p:property> ":" <e:object> => (p.to_string(), e),
};

// =================================
//          Expressions
//

boolean_expression: Box<Expr> = {
    expression,
};

expression: Box<Expr> = {
    simple_expression,
    simple_expression relop simple_expression => Box::new(Expr::BinaryOp(<>)),
};

simple_expression: Box<Expr> = {
    term,
    simple_expression addop term => Box::new(Expr::BinaryOp(<>)),
};

term: Box<Expr> = {
    factor,
    term mulop factor => Box::new(Expr::BinaryOp(<>)),
};

factor: Box<Expr> = {
    sign factor => Box::new(Expr::Signed(<>)),
    exponentiation,
};

exponentiation: Box<Expr> = {
    primary,
    <p:primary> "^" <e:exponentiation> =>
        Box::new(Expr::BinaryOp(p, OpCode::Pow, e)),
};

primary: Box<Expr> = {
    "true" => Box::new(Expr::Boolean(true)),
    "false" => Box::new(Expr::Boolean(false)),
    property => Box::new(Expr::VarAccess(intern(<>))),
    number => Box::new(Expr::Number(<>)),
    "(" <expression> ")" => <>,
    "!" <primary> => Box::new(Expr::Not(<>)),
};

arguments_obj: Vec<ObjectValue> = {
    "(" <comma<object>> ")" => <>,
};

arguments: Vec<Ident> = {
    "(" comma<identspan> ")",
};

sign: Sign = {
    "+" => Sign::Plus,
    "-" => Sign::Minus,
};

addop: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
    "||" => OpCode::Or,
};

mulop: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
    "%" => OpCode::Mod,
    "&&" => OpCode::And,
};

relop: OpCode = {
    "==" => OpCode::EqEq,
    "!=" => OpCode::NotEq,
    "<" => OpCode::LessThan,
    ">" => OpCode::GreaterThan,
    "<=" => OpCode::LessThanOrEq,
    ">=" => OpCode::GreaterThanOrEq,
};

// =================================
//          Tokens
//
extern {
    type Location = usize;
    type Error = tok::Error;
    enum Tok<'input> {
        "import" => Tok::Import,
        "from" => Tok::From,
        "view" => Tok::View,
        "const" => Tok::Const,
        "let" => Tok::Let,
        "component" => Tok::Component,
        "export" => Tok::Export,
        "true" => Tok::True,
        "false" => Tok::False,

        // Style specific tokens
        "@if" => Tok::If,
        "&" => Tok::Ampersand,

        // Special keywords accompanied by a series of
        // uninterpreted strings representing path
        "StringLiteral" => Tok::StringLiteral(<&'input str>),
        "Number" => Tok::Number(<&'input str>),
        "Hex" => Tok::Hex(<&'input str>),

        "TextNode" => Tok::TextNode(<&'input str>), // Includes binded properties

        // Identifiers of various kinds:
        "DotId" => Tok::DotId(<tok::StrView<'input>>), // excludes the '.'
        "Id" => Tok::Id(<tok::StrView<'input>>),

        "->" => Tok::Arrow,

        "{" => Tok::LeftBrace,
        "}" => Tok::RightBrace,
        "[" => Tok::LeftBracket,
        "]" => Tok::RightBracket,
        "(" => Tok::LeftParen,
        ")" => Tok::RightParen,
        "<" => Tok::LessThan,
        "</" => Tok::LessThanSlash,
        ">" => Tok::GreaterThan,
        "/>" => Tok::SlashGreaterThan,

        // Boolean expressions
        "&&" => Tok::And,
        "||" => Tok::Or,
        ">=" => Tok::GreaterThanOrEqual,
        "<=" => Tok::LessThanOrEqual,
        "==" => Tok::EqualsEquals,
        "!=" => Tok::BangEquals,
        //"#" => Tok::Hash,
        //"?" => Tok::Question,
        "/" => Tok::Div,
        "%" => Tok::Mod,
        "|" => Tok::Pipe,
        "!" => Tok::Bang,
        "^" => Tok::Caret,
        "=" => Tok::Equals,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        ";" => Tok::Semi,
        "*" => Tok::Star,
        ":" => Tok::Colon,
        "," => Tok::Comma,
    }
}
