use tok::{self, Tok};
use std::str::FromStr;
use ast::*;
use lalrpop_util::ParseError;
use std::collections::HashMap;

grammar<'input>;

pub ui_package: Package = {
    <vi:import*> <items:template_or_style_or_view*> => {
        Package {
            imports: vi,
            items: items,
        }
    },
};

import: Import = {
    "import" <c:components> "from" <p:path> ";" => {
        Import {
            components: c,
            path: p.to_string(),
        }
    },
    "import" <p:path> ";" => {
        Import {
            components: Components::All,
            path: p.to_string(),
        }
    },
};

components: Components = {
    "*" => Components::All,
    "{" <v:comma<ident>> "}" => {
        Components::Only(v.into_iter().map(|s| s.to_string()).collect())
    },
    <lo:@L> <font_or_img:ident> =>? {
        if font_or_img == "$font" {
            Ok(Components::Font)
        } else if font_or_img == "$img" {
            Ok(Components::Img)
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: lo,
                    code: tok::ErrorCode::OnlyFontOrImg
                }
            })
        }
    },
};

template_or_style_or_view: Item = {
    <t:template> => Item::Template(t),
    <c:style> => Item::Class(c),
    view => Item::View,
    <v:variable> => Item::Variable(v),
};

path: &'input str = {
    "StringLiteral",
};

ident: &'input str = <s:"Id"> => s.as_str();

number: f32 = <n:"Number"> => f32::from_str(n).unwrap();

property: tok::StrView<'input> = {
    "Id",
    <p:property> <d:"DotId"> => p.merge(d),
};

// =================================
//          Templates
//

template: Template = {
    <ex:export?> "template" <n:ident>
    <args:template_args?> <events:trigg_events?> "=" <ns:node*> ";" => {
        Template {
            exported: ex.is_some(),
            name: n.to_string(),
            arguments: args.unwrap_or(vec![]),
            events: events.unwrap_or(vec![]),
            nodes: ns,
        }
    },
};

export: () = "export" => ();

template_args: Vec<String> = {
    <arg:ident> => vec![arg.to_string()],
    "[" <args:comma<ident>> "]" =>
        args.into_iter().map(|s| s.to_string()).collect(),
};

trigg_events: Vec<String> = {
    "->" <evs:events> => evs,
};

events: Vec<String> = {
    <ev:ident> => vec![ev.to_string()],
    "(" <evs:comma<ident>> ")" =>
        evs.into_iter().map(|s| s.to_string()).collect(),
};

node: Node = {
    // Some tag
    "<" <lo:@L> <tag_open:ident> <hi:@R>
        <cl:class?>
        <args:node_args*>
        <ev:node_events*>
    ">"
        node*
    "</" <errlo:@L> <tag_close:ident> ">" =>? {
        if tag_open == tag_close {
            Ok(Node {
                span: Span(lo, hi),
                kind: NodeKind::Tag {
                    class: cl,
                    arguments: args,
                    events: ev,
                },
            })
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: errlo,
                    code: tok::ErrorCode::UnmatchingTag,
                }
            })
        }
    },
    // Selection
    "<" <selo:@L> <select:ident> ":" <qulo:@L> <query:ident> <hi:@R> "/>" =>? {
        if select == "select" {
            if query == "children" {
                Ok(Node {
                    span: Span(selo, hi),
                    kind: NodeKind::Query {
                        kind: QueryKind::Children
                    }
                })
            } else {
                Err(ParseError::User {
                    error: tok::Error {
                        location: qulo,
                        code: tok::ErrorCode::InvalidQuery,
                    }
                })
            }
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: selo,
                    code: tok::ErrorCode::InvalidSelect,
                }
            })
        }
    },
    node_text,
};

node_text: Node = {
    // Text Node (pure text)
    <lo:@L> <t:"TextNode"> <hi:@R> => Node {
        span: Span(lo, hi),
        kind: NodeKind::Text { content: t.to_string() },
    },
    // A text binding
    <lo:@L> "{" <p:property> "}" <hi:@R> => Node {
        span: Span(lo, hi),
        kind: NodeKind::Binding { property: p.to_string() },
    },
};

class: AnonymousClassOrIdent =
    <lo:@L> <clkw:ident> "=" <val:class_value> =>? {
        if clkw == "class" {
            Ok(val)
        } else {
            Err(ParseError::User {
                error: tok::Error {
                    location: lo,
                    code: tok::ErrorCode::UnrecognizedToken,
                }
            })
        }
    };

class_value: AnonymousClassOrIdent = {
    <id:ident> => AnonymousClassOrIdent::Ident(id.to_string()),
    <ac:anonymous_class> => AnonymousClassOrIdent::AnCls(ac),
};

node_args: (String, Box<ObjectValue>) = {
    "[" <i:ident> "]" "=" <a:object_as_arg_value> => (i.to_string(), a),
};

node_events: () = {
    "(" ident ")" "=" property => (),
};

// =================================
//          Styles
//

anonymous_class: AnonymousClass = {
    "{" <props:style_property_or_include*> "}" => {
        AnonymousClass {
            properties: props,
        }
    },
};

style: Class = {
    <ex:export?> <name:"DotId"> <args:style_args?> "{"
        <props:style_property_or_include*>
    "}" => {
        Class {
            exported: ex.is_some(),
            name: (&*name)[1..].to_string(),
            arguments: args.unwrap_or(vec![]),
            properties: props,
        }
    },
};

style_args: Vec<String> = {
    "(" <args:comma<ident>> ")" =>
        args.into_iter().map(|s| s.to_string()).collect(),
};

style_property_or_include: RawPropertyOrInclude = {
    <prop:style_property> <cond:style_condition?> ";" =>
        RawPropertyOrInclude::RawProperty((prop.0, StyleValueCond { prop: prop.1, cond: cond })),
    <incl:style_include>  <cond:style_condition?> ";" =>
        RawPropertyOrInclude::Include(IncludeCond { incl: incl, cond: cond }),
};

style_include: Include = {
    <name:"DotId"> <args:style_args?> => {
        Include {
            name: (&*name)[1..].to_string(),
            arguments: args.unwrap_or(vec![]),
        }
    },
};

style_property: (String, StyleValue) = {
    <i:ident> ":" <s:style_value> => (i.to_string(), s),
};

style_condition: Box<Expr> = {
    "if" <boolean_expression> => <>,
};

style_value: StyleValue = {
    <s:"StringLiteral"> => StyleValue::Keyword(s.to_string()),
    <h:"Hex"> => StyleValue::Hex(h.to_string()),
    <le:@L> <e:expression> <li:@L> <prop:img_view_or_unit?> =>? {
        match prop {
            Some(ImgViewOrUnit::ImgView(sub_img)) => {
                if !is_valid_img_range(&sub_img) {
                    Err(ParseError::User {
                        error: tok::Error {
                            location: li,
                            code: tok::ErrorCode::InvalidRange,
                        }
                    })
                } else if let Expr::VarAccess(access) = *e {
                    let x_pos = sub_img.iter()
                        .position(|&x| x.0.map(|a| a == "x").unwrap_or(false))
                        .unwrap_or(0);
                    let y_pos = sub_img.iter()
                        .position(|&x| x.0.map(|a| a == "y").unwrap_or(false))
                        .unwrap_or(1);
                    let w_pos = sub_img.iter()
                        .position(|&x| x.0.map(|a| a == "w").unwrap_or(false))
                        .unwrap_or(2);
                    let h_pos = sub_img.iter()
                        .position(|&x| x.0.map(|a| a == "h").unwrap_or(false))
                        .unwrap_or(3);
                    Ok(StyleValue::Img {
                        ident: access.to_string(),
                        view_x: sub_img.get(x_pos).map(|&x| x.1),
                        view_y: sub_img.get(y_pos).map(|&x| x.1),
                        view_w: sub_img.get(w_pos).map(|&x| x.1),
                        view_h: sub_img.get(h_pos).map(|&x| x.1),
                    })
                } else {
                    Err(ParseError::User {
                        error: tok::Error {
                            location: le,
                            code: tok::ErrorCode::InvalidVarName
                        }
                    })
                }
            }
            Some(ImgViewOrUnit::Unit(u)) => {
                Ok(StyleValue::Length(e, u))
            }
            None => {
                Ok(StyleValue::Unspecified(e))
            }
        }
    },
};

style_unit: Unit = {
    <li:@L> <u:ident> =>? match u {
        "px" => Ok(Unit::Px),
        _ => Err(ParseError::User {
            error: tok::Error {
                location: li,
                code: tok::ErrorCode::InvalidUnit
            }
        })
    },
};

img_view_or_unit: ImgViewOrUnit<'input> = {
    <prop:img_props> => ImgViewOrUnit::ImgView(prop),
    <unit:style_unit> => ImgViewOrUnit::Unit(unit),
};

img_props: Vec<(Option<&'input str>, f32)> = {
    "[" <v:comma<img_prop>> "]" => v,
};

img_prop: (Option<&'input str>, f32) = {
    <i:ident> ":" <n:number> => (Some(i), n),
    <n:number> => (None, n),
};

// =================================
//          Variables
//

variable: Variable = {
    "let" <n:ident> "=" <o:object> ";" => Variable {
        name: n.to_string(),
        properties: o,
    },
};

// =================================
//          View
//

view: () = {
    "view" "Id" view_args "=" node ";" => (),
};

view_args: () = {
    "(" ident "," ident ")" => (),
};

// =================================
//          Macros
//

comma<T>: Vec<T> =
    <v:(<T> ",")*> <o:T?> =>
        v.into_iter().chain(o).collect();

// =================================
//          Objects
//

// Almost similar as below. Note the difference
// with expression replaced by property
// This is needed to avoid a problem with expression
// that need to be wrapped
object_as_arg_value: Box<ObjectValue> = {
    <s:"StringLiteral"> => Box::new(ObjectValue::StrLit(s.to_string())),
    <p:property> =>
        Box::new(ObjectValue::Expr(Box::new(Expr::VarAccess(p.to_string())))),
    "{" <exp:expression> "}" => Box::new(ObjectValue::Expr(exp)),
    "{" <entries:comma<object_entry>> "}" =>
        Box::new(ObjectValue::Props(entries.into_iter().collect())),
};

object: Box<ObjectValue> = {
    <s:"StringLiteral"> => Box::new(ObjectValue::StrLit(s.to_string())),
    <exp:expression> => Box::new(ObjectValue::Expr(exp)),
    "{" <entries:comma<object_entry>> "}" =>
        Box::new(ObjectValue::Props(entries.into_iter().collect())),
};

object_entry: (String, Box<ObjectValue>) = {
    <p:property> ":" <e:object> => (p.to_string(), e),
};

// =================================
//          Expressions
//

boolean_expression: Box<Expr> = {
    expression,
};

expression: Box<Expr> = {
    simple_expression,
    simple_expression relop simple_expression => Box::new(Expr::BinaryOp(<>)),
};

simple_expression: Box<Expr> = {
    term,
    simple_expression addop term => Box::new(Expr::BinaryOp(<>)),
};

term: Box<Expr> = {
    factor,
    term mulop factor => Box::new(Expr::BinaryOp(<>)),
};

factor: Box<Expr> = {
    sign factor => Box::new(Expr::Signed(<>)),
    exponentiation,
};

exponentiation: Box<Expr> = {
    primary,
    <p:primary> "^" <e:exponentiation> =>
        Box::new(Expr::BinaryOp(p, OpCode::Pow, e)),
};

primary: Box<Expr> = {
    property => Box::new(Expr::VarAccess(<>.to_string())),
    number => Box::new(Expr::Number(<>)),
    "(" <expression> ")" => <>,
    "!" <primary> => Box::new(Expr::Not(<>)),
};

sign: Sign = {
    "+" => Sign::Plus,
    "-" => Sign::Minus,
};

addop: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
    "||" => OpCode::Or,
};

mulop: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
    "%" => OpCode::Mod,
    "&&" => OpCode::And,
};

relop: OpCode = {
    "==" => OpCode::EqEq,
    "!=" => OpCode::NotEq,
    "<" => OpCode::LessThan,
    ">" => OpCode::GreaterThan,
    "<=" => OpCode::LessThanOrEq,
    ">=" => OpCode::GreaterThanOrEq,
};

// =================================
//          Tokens
//
extern {
    type Location = usize;
    type Error = tok::Error;
    enum Tok<'input> {
        "import" => Tok::Import,
        "from" => Tok::From,
        "view" => Tok::View,
        "template" => Tok::Template,
        "export" => Tok::Export,
        "if" => Tok::If,
        "let" => Tok::Let,

        // Special keywords accompanied by a series of
        // uninterpreted strings representing path
        "StringLiteral" => Tok::StringLiteral(<&'input str>),
        "Number" => Tok::Number(<&'input str>),
        "Hex" => Tok::Hex(<&'input str>),

        "TextNode" => Tok::TextNode(<&'input str>), // Includes binded properties

        // Identifiers of various kinds:
        "DotId" => Tok::DotId(<tok::StrView<'input>>), // excludes the '.'
        "Id" => Tok::Id(<tok::StrView<'input>>),

        "->" => Tok::Arrow,

        "{" => Tok::LeftBrace,
        "}" => Tok::RightBrace,
        "[" => Tok::LeftBracket,
        "]" => Tok::RightBracket,
        "(" => Tok::LeftParen,
        ")" => Tok::RightParen,
        "<" => Tok::LessThan,
        "</" => Tok::LessThanSlash,
        ">" => Tok::GreaterThan,
        "/>" => Tok::SlashGreaterThan,

        // Boolean expressions
        "&&" => Tok::And,
        "||" => Tok::Or,
        ">=" => Tok::GreaterThanOrEqual,
        "<=" => Tok::LessThanOrEqual,
        "==" => Tok::EqualsEquals,
        "!=" => Tok::BangEquals,
        //"#" => Tok::Hash,
        //"?" => Tok::Question,
        "/" => Tok::Div,
        "%" => Tok::Mod,
        "|" => Tok::Pipe,
        "!" => Tok::Bang,
        "^" => Tok::Caret,
        "=" => Tok::Equals,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        ";" => Tok::Semi,
        "*" => Tok::Star,
        ":" => Tok::Colon,
        "," => Tok::Comma,
    }
}
