// Generated:
//
// static KEYWORDS: phf::Map<&'static str, KwValue> = phf_map! { ... };
//
// static KEYWORDS_SELECTOR_STATE: phf::Map<&'static str, SelectorState> = phf_map! { ... };
//
// with:

//include!(concat!(env!("OUT_DIR"), "/keyword_style_parser_phf_generated.rs"));
#[cfg(test)]
mod test;

/*
This is the tree generated by the parser generated by lalrpop.
*/

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Package {
    pub imports: Vec<Import>,
    pub items: Vec<Item>,
}

#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub struct Span(pub usize, pub usize);

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Import {
    pub components: Components,
    pub path: String,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Components {
    All,
    Img,
    Font,
    Only(Vec<String>),
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Item {
    View,
    Template(Template),
    Class,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Template {
    pub exported: bool,
    pub name: String,
    pub arguments: Vec<String>,
    pub events: Vec<String>,
    pub nodes: Vec<Node>,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Node {
    pub span: Span,
    pub kind: NodeKind,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum NodeKind {
    Text {
        content: String
    },
    Binding {
        property: String,
    },
    Tag {
        class: Option<()>,
        arguments: Vec<()>,
        events: Vec<()>,
    },
    Query {
        kind: QueryKind,
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum QueryKind {
    Children
}
